<!DOCTYPE html>
<html lang="en-US">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <link href="CSS/main.css" rel="stylesheet" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NodeJS</title>
</head>

<body>
    <header>
        <h1 id="headtop">
            <a id="heading" href="index.html">SGThomasJr<span>.com</span></a>
        </h1>
    </header>
    <ul id="navbar">
        <li id="navlist"><a href="index.html">Home</a></li>
        <li id="navlist"><a href="html.html">HTML</a></li>
        <li id="navlist"><a href="css.html">CSS</a></li>
        <li id="navlist"><a href="java.html">JavaScript</a></li>
        <li id="navlist"><a class="active" href="node.html">NodeJS</a></li>
        <li id="navlist"><a href="sql.html">SQL</a></li>
        <!--<li style="float:right" id="navlist"><a href="wp/">Blog</a></li>-->
    </ul>
    <div class="container">
        <h2>Welcome to the World of Automation</h2>
        <h3>First stop Node.js</h3>
        <p>In order to create a proper testing environment we need Node.js. As an asynchronous event-driven JavaScript runtime, Node.js is designed to build scalable network applications. Later we will create a "Hello World" example, showing that many connections
            can be handled concurrently. Upon each connection, the callback is fired, but if there is no work to be done, Node.js will sleep.</p>
        <p>This is in contrast to today's more common concurrency model, in which OS threads are employed. Thread-based networking is relatively inefficient and very difficult to use. Furthermore, users of Node.js are free from worries of dead-locking the
            process, since there are no locks. Almost no function in Node.js directly performs I/O, so the process never blocks except when the I/O is performed using synchronous methods of Node.js standard library. Because nothing blocks, scalable systems
            are very reasonable to develop in Node.js.</p>
        <p>If some of this language is unfamiliar, there is a full article on <a class="URL" href="https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/">Blocking vs. Non-Blocking</a>.</p>
        <p>Node.js is similar in design to, and influenced by, systems like Ruby's Event Machine and Python's Twisted. Node.js takes the event model a bit further. It presents an event loop as a runtime construct instead of as a library. In other systems,
            there is always a blocking call to start the event-loop. Typically, behavior is defined through callbacks at the beginning of a script, and at the end a server is started through a blocking call like EventMachine::run(). In Node.js, there
            is no such start-the-event-loop call. Node.js simply enters the event loop after executing the input script. Node.js exits the event loop when there are no more callbacks to perform. This behavior is like browser JavaScript — the event loop
            is hidden from the user.</p>

        <p>HTTP is a first-class citizen in Node.js, designed with streaming and low latency in mind. This makes Node.js well suited for the foundation of a web library or framework.</p>

        <p>Node.js being designed without threads doesn't mean you can't take advantage of multiple cores in your environment. Child processes can be spawned by using our child_process.fork() API, and are designed to be easy to communicate with. Built upon
            that same interface is the cluster module, which allows you to share sockets between processes to enable load balancing over your cores.</p>
        <div class="indent">
            <p>Download the latest version at <a class="URL" href="https://nodejs.org/en/">https://nodejs.org/en</a>. Once installation is complete, run <b>node -v</b> in terminal to verify version.</p>
            <p><a class="URL" href="https://www.lambdatest.com/blog/nodejs-best-practices/">23 Node.js Best Practices For Automation</a></p>
        </div>

        <h3>Selenium and the WebDriver</h3>

        <p>Selenium is an umbrella project for a range of tools and libraries that enable and support the automation of web browsers. It provides extensions to emulate user interaction with browsers, a distribution server for scaling browser allocation,
            and the infrastructure for implementations of the W3C WebDriver specification that lets you write interchangeable code for all major web browsers. At the core of Selenium is WebDriver, an interface to write instruction sets that can be run
            interchangeably in many browsers. Once you’ve installed everything, only a few lines of code get you inside a browser.</p>
        <p>It supports automation of all the major browsers in the market through the use of WebDriver. WebDriver is an API and protocol that defines a language-neutral interface for controlling the behaviour of web browsers. Each browser is backed by a
            specific WebDriver implementation, called a driver. The driver is the component responsible for delegating down to the browser, and handles communication to and from Selenium and the browser.</p>
        <p>This separation is part of a conscious effort to have browser vendors take responsibility for the implementation for their browsers. Selenium makes use of these third party drivers where possible, but also provides its own drivers maintained by
            the project for the cases when this is not a reality. The Selenium framework ties all of these pieces together through a user-facing interface that enables the different browser backends to be used transparently, enabling cross-browser and
            cross-platform automation.
        </p>
        <p>Selenium setup is quite different from the setup of other commercial tools. Before you can start writing Selenium code, you have to install the language bindings libraries for your language of choice, the browser you want to use, and the driver
            for that browser.</p>
        <div class="indent">
            <p>Now that Node.js is ready, the next step is the JavaScript library. Use the command <b>npm install selenium-webdriver</b> to finalize the language creation. <a class="URL" href="https://www.w3schools.com/whatis/whatis_npm.asp">So what is npm?</a></p>
            <p>The last step is to installed the ChromeDriver from the <a class="URL" href="https://chromedriver.chromium.org/downloads">Current Releases</a> download, but make sure to use the correct Chrome browser version. You must include the <b>ChromeDriver</b>                location in your <b>PATH</b> environment variable. Run command <b>echo $PATH</b> to find the current directory variables and copy the driver to one of these locations. </b>Also see <a class="URL" href="https://chromedriver.chromium.org/getting-started">Getting started with ChromeDriver</a>                for more information.</p>
            <p>If you wish to start with a low-code/record and playback tool, please check
                <a class="URL" href="https://www.selenium.dev/selenium-ide/">Selenium IDE</a>. For more advanced configurations head to <a class="URL" href="https://www.selenium.dev/documentation/grid/">Selenium Grid</a> to allow running parallel tests
                across multiple machines.
            </p>
            <p>Highly recommend the official <a class="URL" href="https://www.selenium.dev/documentation/webdriver/elements/">Web Elements</a> documentation to get acquainted with identifying and working with element objects in the DOM. The majority of most
                people’s Selenium code involves working with web elements.</p>
            <p><b>LambaTest Blog Post -</b> <a class="URL" href="https://www.lambdatest.com/blog/how-to-run-automation-tests-using-selenium-and-nodejs/">Automation Tests Using Selenium and NodeJS</a></p>
        </div>

        <h3>Mocha JavaScript test framework</h3>
        <p><a class="URL" href="https://mochajs.org/">https://mochajs.org</a></p>
        <p>Mocha is a feature-rich JavaScript test framework running on Node.js and in the browser, making asynchronous testing simple and fun. Mocha tests run serially, allowing for flexible and accurate reporting, while mapping uncaught exceptions to the
            correct test cases. Hosted on GitHub.</p>
        <p><a class="URL" href="https://www.lambdatest.com/blog/mocha-javascript-tutorial-with-examples-for-selenium-testing/">Mocha JavaScript Tutorial With Selenium</a></p>



    </div>

</body>

</html>